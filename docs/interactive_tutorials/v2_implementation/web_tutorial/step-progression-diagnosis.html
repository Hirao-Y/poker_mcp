<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>🚨 ステップ進行異常 緊急診断システム</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #fff0f0; }
        .critical-panel { margin: 15px 0; padding: 20px; background: white; border-radius: 8px; border: 3px solid #dc3545; }
        .diagnostic-panel { margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #007bff; }
        .result-panel { margin: 10px 0; padding: 12px; border-radius: 6px; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .info { background: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; }
        .critical { background: #f5c6cb; border: 2px solid #dc3545; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        button { padding: 12px 20px; margin: 8px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; }
        .btn-critical { background: #dc3545; color: white; font-size: 16px; }
        .btn-diagnostic { background: #007bff; color: white; }
        .btn-fix { background: #28a745; color: white; }
        pre { background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 11px; white-space: pre-wrap; }
        .step-flow { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 20px 0; }
        .step-box { padding: 10px; text-align: center; border-radius: 6px; font-weight: bold; }
        .step-normal { background: #e9ecef; color: #495057; }
        .step-current { background: #007bff; color: white; }
        .step-error { background: #dc3545; color: white; }
        .step-skip { background: #ffc107; color: #212529; }
    </style>
</head>
<body>
    <h1>🚨 ステップ進行異常 緊急診断システム</h1>
    
    <div class="critical-panel">
        <h2>⚠️ 深刻な進行異常を検出</h2>
        <p><strong>報告された異常:</strong></p>
        <ul>
            <li>❌ Step 1 → Step 2 への進行失敗（Step 3にスキップ）</li>
            <li>❌ Step 3 → Step 4 への進行失敗（進行停止）</li>
        </ul>
        
        <div class="step-flow">
            <div class="step-box step-normal">Step 1</div>
            <div class="step-box step-error">Step 2<br>スキップされる</div>
            <div class="step-box step-skip">Step 3<br>異常到達</div>
            <div class="step-box step-error">Step 4<br>到達不能</div>
            <div class="step-box step-normal">Step 5</div>
        </div>
        
        <button onclick="emergencyStepDiagnosis()" class="btn-critical">🔍 緊急ステップ診断</button>
        <button onclick="testAllStepProgression()" class="btn-diagnostic">🧪 全ステップ進行テスト</button>
        <button onclick="fixStepProgression()" class="btn-fix">⚡ 進行修復実行</button>
        <button onclick="resetToStep1()" class="btn-fix">🔄 Step 1へリセット</button>
    </div>

    <div id="diagnosticResults"></div>
    
    <div class="diagnostic-panel">
        <h3>📊 リアルタイム進行監視</h3>
        <div id="progressMonitor"></div>
        <button onclick="startContinuousMonitoring()" class="btn-diagnostic">📈 連続監視開始</button>
        <button onclick="stopMonitoring()" class="btn-critical">⏹️ 監視停止</button>
    </div>

    <script src="physics-validator.js"></script>
    <script src="cross-section-visualizer.js"></script>
    <script src="tutorial.js"></script>

    <script>
        let resultsDiv = document.getElementById('diagnosticResults');
        let progressMonitor = document.getElementById('progressMonitor');
        let monitoringInterval = null;

        function addResult(title, type, message, details = '') {
            const resultDiv = document.createElement('div');
            resultDiv.className = `result-panel ${type}`;
            resultDiv.innerHTML = `
                <h3>${getIcon(type)} ${title}</h3>
                <p><strong>診断結果:</strong> ${message}</p>
                ${details ? `<pre>${details}</pre>` : ''}
                <small>診断時刻: ${new Date().toLocaleTimeString()}</small>
            `;
            resultsDiv.appendChild(resultDiv);
            
            // スクロール
            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function getIcon(type) {
            switch(type) {
                case 'success': return '✅';
                case 'error': return '❌';
                case 'warning': return '⚠️';
                case 'critical': return '🚨';
                default: return 'ℹ️';
            }
        }

        function emergencyStepDiagnosis() {
            resultsDiv.innerHTML = '';
            console.log('🚨 緊急ステップ診断開始...');

            // 1. チュートリアル状態の完全確認
            diagnoseCurrentState();
            
            // 2. nextStep()メソッドの詳細分析
            diagnoseNextStepMethod();
            
            // 3. ステップデータの整合性確認
            diagnoseStepDataIntegrity();
            
            // 4. 進行ロジックの詳細確認
            diagnoseProgressionLogic();
            
            // 5. DOM要素とイベントの確認
            diagnoseDOMEvents();
        }

        function diagnoseCurrentState() {
            try {
                if (!window.tutorial) {
                    addResult('現在状態診断', 'critical', 'tutorialオブジェクトが存在しません');
                    return;
                }

                const tutorial = window.tutorial;
                const currentState = {
                    currentStep: tutorial.currentStep,
                    totalSteps: tutorial.totalSteps,
                    tutorialStepsLoaded: tutorial.tutorialSteps?.length,
                    tutorialStepsValid: Array.isArray(tutorial.tutorialSteps),
                    stepNumbers: tutorial.tutorialSteps?.map(s => s?.step),
                    currentStepTitle: document.getElementById('stepTitle')?.textContent,
                    currentStepBadge: document.getElementById('stepBadge')?.textContent,
                    modalVisible: document.getElementById('modalOverlay')?.style?.display === 'flex',
                    nextBtnDisabled: tutorial.nextBtn?.disabled
                };

                // 異常パターンの確認
                const anomalies = [];
                if (currentState.currentStep !== 1 && currentState.currentStep !== 2 && currentState.currentStep !== 3) {
                    anomalies.push(`異常なcurrentStep値: ${currentState.currentStep}`);
                }
                if (currentState.stepNumbers && !currentState.stepNumbers.includes(currentState.currentStep)) {
                    anomalies.push(`currentStepがtutorialStepsに存在しない`);
                }
                if (currentState.tutorialStepsLoaded !== 5) {
                    anomalies.push(`期待値5に対してステップ数が${currentState.tutorialStepsLoaded}`);
                }

                addResult('現在状態診断', anomalies.length > 0 ? 'error' : 'success',
                    anomalies.length > 0 ? `${anomalies.length}件の異常を検出` : '基本状態は正常',
                    `現在状態:\n${JSON.stringify(currentState, null, 2)}\n\n異常:\n${anomalies.join('\n')}`
                );

            } catch (error) {
                addResult('現在状態診断', 'critical', `診断エラー: ${error.message}`, error.stack);
            }
        }

        function diagnoseNextStepMethod() {
            try {
                if (!window.tutorial) return;

                const tutorial = window.tutorial;
                
                // nextStepメソッドの内容を文字列として取得
                const nextStepCode = tutorial.nextStep.toString();
                
                // 重要な処理が含まれているかチェック
                const codeAnalysis = {
                    hasCurrentStepIncrement: nextStepCode.includes('this.currentStep++'),
                    hasUpdateStepContent: nextStepCode.includes('updateStepContent'),
                    hasResetCode: nextStepCode.includes('resetCode'),
                    hasUpdateProgress: nextStepCode.includes('updateProgress'),
                    hasTotalStepsCheck: nextStepCode.includes('this.totalSteps'),
                    hasHideModal: nextStepCode.includes('hideCompletionModal'),
                    methodLength: nextStepCode.length
                };

                // 手動でnextStep()を実行してみる（現在の状態を保存）
                const beforeStep = tutorial.currentStep;
                console.log('🧪 nextStep()手動実行テスト...');
                
                // 安全にテスト実行
                try {
                    const originalStep = tutorial.currentStep;
                    tutorial.nextStep();
                    
                    setTimeout(() => {
                        const afterStep = tutorial.currentStep;
                        const stepChanged = afterStep !== originalStep;
                        const expectedNextStep = originalStep + 1;
                        const correctProgression = afterStep === expectedNextStep;
                        
                        const testResult = {
                            beforeStep: originalStep,
                            afterStep: afterStep,
                            stepChanged: stepChanged,
                            correctProgression: correctProgression,
                            stepSkipped: afterStep > expectedNextStep,
                            progressionDifference: afterStep - originalStep
                        };

                        if (correctProgression) {
                            addResult('nextStep()実行テスト', 'success',
                                'nextStep()は正常に動作します',
                                `テスト結果:\n${JSON.stringify(testResult, null, 2)}\n\nメソッド分析:\n${JSON.stringify(codeAnalysis, null, 2)}`
                            );
                        } else {
                            addResult('nextStep()実行テスト', 'error',
                                `nextStep()に異常があります: ${originalStep} → ${afterStep}`,
                                `テスト結果:\n${JSON.stringify(testResult, null, 2)}\n\nメソッド分析:\n${JSON.stringify(codeAnalysis, null, 2)}`
                            );
                        }
                        
                        // テスト用に元に戻す
                        tutorial.currentStep = originalStep;
                        tutorial.updateStepContent();
                        tutorial.updateProgress();
                        
                    }, 300);

                } catch (methodError) {
                    addResult('nextStep()実行テスト', 'critical',
                        `nextStep()実行でエラー: ${methodError.message}`,
                        `エラー詳細:\n${methodError.stack}\n\nメソッド分析:\n${JSON.stringify(codeAnalysis, null, 2)}`
                    );
                }

            } catch (error) {
                addResult('nextStep()メソッド診断', 'error', `診断エラー: ${error.message}`);
            }
        }

        function diagnoseStepDataIntegrity() {
            try {
                if (!window.tutorial || !window.tutorial.tutorialSteps) {
                    addResult('ステップデータ整合性', 'error', 'tutorialStepsが利用できません');
                    return;
                }

                const steps = window.tutorial.tutorialSteps;
                
                // 各ステップの詳細確認
                const stepDetails = steps.map(step => ({
                    step: step?.step,
                    title: step?.title?.substring(0, 30),
                    hasTemplate: !!step?.template,
                    hasPhysicsBackground: !!step?.physics_background,
                    hasInstructions: !!step?.instructions,
                    templateLength: step?.template?.length
                }));

                // 整合性チェック
                const issues = [];
                const stepNumbers = steps.map(s => s?.step).sort((a, b) => a - b);
                const expectedNumbers = [1, 2, 3, 4, 5];
                
                if (JSON.stringify(stepNumbers) !== JSON.stringify(expectedNumbers)) {
                    issues.push(`ステップ番号の不整合: 期待値[1,2,3,4,5] 実際[${stepNumbers.join(',')}]`);
                }

                // 重複チェック
                const duplicates = stepNumbers.filter((item, index) => stepNumbers.indexOf(item) !== index);
                if (duplicates.length > 0) {
                    issues.push(`重複ステップ番号: [${duplicates.join(',')}]`);
                }

                // 欠損チェック
                const missing = expectedNumbers.filter(num => !stepNumbers.includes(num));
                if (missing.length > 0) {
                    issues.push(`欠損ステップ番号: [${missing.join(',')}]`);
                }

                // テンプレート確認
                const templatesIssues = stepDetails.filter(s => s.step <= 4 && !s.hasTemplate);
                if (templatesIssues.length > 0) {
                    issues.push(`テンプレート欠損: Step ${templatesIssues.map(s => s.step).join(',')}`);
                }

                addResult('ステップデータ整合性', issues.length === 0 ? 'success' : 'error',
                    issues.length === 0 ? 'ステップデータの整合性は正常' : `${issues.length}件の整合性問題を検出`,
                    `ステップ詳細:\n${JSON.stringify(stepDetails, null, 2)}\n\n問題:\n${issues.join('\n')}`
                );

            } catch (error) {
                addResult('ステップデータ整合性', 'error', `確認エラー: ${error.message}`);
            }
        }

        function diagnoseProgressionLogic() {
            try {
                if (!window.tutorial) return;

                const tutorial = window.tutorial;
                
                // 進行ロジックの状況確認
                const progressionState = {
                    currentStep: tutorial.currentStep,
                    totalSteps: tutorial.totalSteps,
                    canProgressCheck: tutorial.currentStep < tutorial.totalSteps,
                    nextStepWouldBe: tutorial.currentStep + 1,
                    targetStepExists: tutorial.tutorialSteps?.find(s => s?.step === (tutorial.currentStep + 1)),
                    currentStepData: tutorial.tutorialSteps?.find(s => s?.step === tutorial.currentStep)
                };

                // 各ステップへの進行可能性をテスト
                const progressionTests = [];
                for (let targetStep = 1; targetStep <= 5; targetStep++) {
                    const stepData = tutorial.tutorialSteps?.find(s => s?.step === targetStep);
                    progressionTests.push({
                        targetStep: targetStep,
                        exists: !!stepData,
                        title: stepData?.title,
                        canAccess: !!stepData,
                        hasTemplate: !!stepData?.template
                    });
                }

                // Step 1→2→3の進行パスをシミュレーション
                console.log('🔄 進行パスシミュレーション開始...');
                const simulationResults = [];
                
                // 現在の状態を保存
                const originalStep = tutorial.currentStep;
                
                try {
                    // Step 1に設定
                    tutorial.currentStep = 1;
                    const step1Data = tutorial.tutorialSteps?.find(s => s?.step === 1);
                    simulationResults.push({
                        fromStep: 'initial',
                        toStep: 1,
                        success: !!step1Data,
                        data: !!step1Data
                    });

                    // Step 1→2をシミュレーション
                    tutorial.currentStep = 2;
                    const step2Data = tutorial.tutorialSteps?.find(s => s?.step === 2);
                    simulationResults.push({
                        fromStep: 1,
                        toStep: 2,
                        success: !!step2Data,
                        data: !!step2Data
                    });

                    // Step 2→3をシミュレーション
                    tutorial.currentStep = 3;
                    const step3Data = tutorial.tutorialSteps?.find(s => s?.step === 3);
                    simulationResults.push({
                        fromStep: 2,
                        toStep: 3,
                        success: !!step3Data,
                        data: !!step3Data
                    });

                } finally {
                    // 元の状態に復旧
                    tutorial.currentStep = originalStep;
                }

                addResult('進行ロジック診断', 'success',
                    '進行ロジックの詳細分析が完了',
                    `進行状況:\n${JSON.stringify(progressionState, null, 2)}\n\n進行テスト:\n${JSON.stringify(progressionTests, null, 2)}\n\nシミュレーション:\n${JSON.stringify(simulationResults, null, 2)}`
                );

            } catch (error) {
                addResult('進行ロジック診断', 'error', `診断エラー: ${error.message}`);
            }
        }

        function diagnoseDOMEvents() {
            try {
                const continueBtn = document.getElementById('continueBtn');
                const nextBtn = document.getElementById('nextBtn');
                const modalOverlay = document.getElementById('modalOverlay');
                
                const domState = {
                    continueBtn: {
                        exists: !!continueBtn,
                        disabled: continueBtn?.disabled,
                        visible: continueBtn ? window.getComputedStyle(continueBtn).display !== 'none' : false,
                        hasOnClick: !!continueBtn?.onclick,
                        text: continueBtn?.textContent
                    },
                    nextBtn: {
                        exists: !!nextBtn,
                        disabled: nextBtn?.disabled,
                        visible: nextBtn ? window.getComputedStyle(nextBtn).display !== 'none' : false,
                        hasOnClick: !!nextBtn?.onclick,
                        text: nextBtn?.textContent
                    },
                    modalOverlay: {
                        exists: !!modalOverlay,
                        visible: modalOverlay?.style?.display === 'flex'
                    },
                    tutorialReference: {
                        continueBtnRef: window.tutorial?.continueBtn === continueBtn,
                        nextBtnRef: window.tutorial?.nextBtn === nextBtn,
                        modalRef: window.tutorial?.modalOverlay === modalOverlay
                    }
                };

                // イベントリスナーのテスト
                let eventTestResults = [];
                
                if (continueBtn && window.tutorial) {
                    // 一時的にクリックイベントをシミュレーション（実際には発火させない）
                    eventTestResults.push({
                        element: 'continueBtn',
                        hasEventListener: true, // この判定は簡略化
                        canTrigger: typeof window.tutorial.nextStep === 'function'
                    });
                }

                addResult('DOM・イベント診断', 'success',
                    'DOM要素とイベント状況の確認完了',
                    `DOM状況:\n${JSON.stringify(domState, null, 2)}\n\nイベントテスト:\n${JSON.stringify(eventTestResults, null, 2)}`
                );

            } catch (error) {
                addResult('DOM・イベント診断', 'error', `診断エラー: ${error.message}`);
            }
        }

        function testAllStepProgression() {
            console.log('🧪 全ステップ進行テスト開始...');
            
            if (!window.tutorial) {
                addResult('全ステップテスト', 'error', 'tutorialオブジェクトが利用できません');
                return;
            }

            const tutorial = window.tutorial;
            const originalStep = tutorial.currentStep;
            const testResults = [];

            // Step 1から順番にテスト
            let currentTestStep = 1;
            
            const runStepTest = () => {
                if (currentTestStep > 5) {
                    // 全テスト完了
                    tutorial.currentStep = originalStep;
                    tutorial.updateStepContent();
                    tutorial.updateProgress();
                    
                    addResult('全ステップテスト', 'success',
                        '全5ステップのテストが完了',
                        `テスト結果:\n${JSON.stringify(testResults, null, 2)}`
                    );
                    return;
                }

                console.log(`Step ${currentTestStep} テスト中...`);
                
                // ステップを設定
                tutorial.currentStep = currentTestStep;
                
                try {
                    tutorial.updateStepContent();
                    tutorial.resetCode();
                    tutorial.updateProgress();
                    
                    setTimeout(() => {
                        const stepTitle = document.getElementById('stepTitle')?.textContent;
                        const stepBadge = document.getElementById('stepBadge')?.textContent;
                        const hasCode = document.getElementById('codeEditor')?.textContent?.length > 0;
                        
                        testResults.push({
                            step: currentTestStep,
                            success: !!stepTitle && stepBadge?.includes(`Step ${currentTestStep}`),
                            title: stepTitle,
                            badge: stepBadge,
                            hasCode: hasCode,
                            timestamp: new Date().toLocaleTimeString()
                        });

                        currentTestStep++;
                        runStepTest();
                    }, 200);

                } catch (error) {
                    testResults.push({
                        step: currentTestStep,
                        success: false,
                        error: error.message,
                        timestamp: new Date().toLocaleTimeString()
                    });

                    currentTestStep++;
                    runStepTest();
                }
            };

            runStepTest();
        }

        function fixStepProgression() {
            console.log('⚡ ステップ進行修復開始...');
            
            if (!window.tutorial) {
                addResult('進行修復', 'error', 'tutorialオブジェクトが利用できません');
                return;
            }

            try {
                const tutorial = window.tutorial;
                
                // 1. Step 1に強制リセット
                tutorial.currentStep = 1;
                tutorial.updateStepContent();
                tutorial.resetCode();
                tutorial.updateProgress();
                tutorial.clearResults();
                
                // 2. モーダルを閉じる
                if (tutorial.modalOverlay) {
                    tutorial.modalOverlay.style.display = 'none';
                }
                
                // 3. ボタン状態をリセット
                if (tutorial.nextBtn) {
                    tutorial.nextBtn.disabled = false;
                }
                
                // 4. イベントリスナーを再設定
                if (tutorial.continueBtn) {
                    tutorial.continueBtn.onclick = (e) => {
                        e.preventDefault();
                        console.log('🔄 修復されたcontinueBtn クリック!');
                        tutorial.nextStep();
                    };
                }

                setTimeout(() => {
                    const currentTitle = document.getElementById('stepTitle')?.textContent;
                    const currentBadge = document.getElementById('stepBadge')?.textContent;
                    
                    addResult('進行修復', 'success',
                        'ステップ進行の修復が完了しました',
                        `修復結果:\ncurrentStep: ${tutorial.currentStep}\nステップタイトル: ${currentTitle}\nステップバッジ: ${currentBadge}\nモーダル状態: 非表示\nボタン状態: 有効`
                    );
                }, 500);

            } catch (error) {
                addResult('進行修復', 'error', `修復エラー: ${error.message}`);
            }
        }

        function resetToStep1() {
            console.log('🔄 Step 1へのリセット実行...');
            
            try {
                if (window.tutorial) {
                    const tutorial = window.tutorial;
                    tutorial.currentStep = 1;
                    tutorial.updateStepContent();
                    tutorial.resetCode();
                    tutorial.updateProgress();
                    tutorial.clearResults();
                    
                    if (tutorial.modalOverlay) {
                        tutorial.modalOverlay.style.display = 'none';
                    }
                    
                    if (tutorial.nextBtn) {
                        tutorial.nextBtn.disabled = false;
                    }
                    
                    addResult('Step 1リセット', 'success', 'Step 1への リセットが完了しました');
                } else {
                    addResult('Step 1リセット', 'error', 'tutorialオブジェクトが利用できません');
                }
            } catch (error) {
                addResult('Step 1リセット', 'error', `リセットエラー: ${error.message}`);
            }
        }

        function startContinuousMonitoring() {
            if (monitoringInterval) stopMonitoring();

            monitoringInterval = setInterval(() => {
                if (window.tutorial) {
                    const tutorial = window.tutorial;
                    const now = new Date().toLocaleTimeString();
                    
                    const status = {
                        time: now,
                        currentStep: tutorial.currentStep,
                        stepTitle: document.getElementById('stepTitle')?.textContent?.substring(0, 25),
                        stepBadge: document.getElementById('stepBadge')?.textContent,
                        modalVisible: document.getElementById('modalOverlay')?.style?.display === 'flex',
                        nextBtnDisabled: tutorial.nextBtn?.disabled,
                        continueBtnExists: !!document.getElementById('continueBtn')
                    };

                    progressMonitor.innerHTML = `
                        <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 4px; border-left: 4px solid #007bff;">
                            ⏰ ${status.time} | 📍 Step ${status.currentStep} | 🏷️ ${status.stepBadge}
                            <br>📝 ${status.stepTitle} | 🎭 Modal: ${status.modalVisible ? 'ON' : 'OFF'} | ➡️ Next: ${status.nextBtnDisabled ? 'OFF' : 'ON'}
                        </div>
                    ` + progressMonitor.innerHTML;

                    // 最新10件のみ保持
                    const entries = progressMonitor.children;
                    while (entries.length > 10) {
                        entries[entries.length - 1].remove();
                    }

                } else {
                    progressMonitor.innerHTML = `
                        <div style="padding: 8px; margin: 5px 0; background: #f8d7da; border-radius: 4px; border-left: 4px solid #dc3545;">
                            ❌ ${new Date().toLocaleTimeString()} | tutorialオブジェクトが利用できません
                        </div>
                    ` + progressMonitor.innerHTML;
                }
            }, 3000);

            addResult('連続監視', 'success', '連続監視を開始しました（3秒間隔）');
        }

        function stopMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
                addResult('連続監視', 'success', '連続監視を停止しました');
            }
        }

        // 初期状態確認
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (window.tutorial) {
                    addResult('システム初期化', 'success',
                        `診断システム初期化完了 - 現在Step ${window.tutorial.currentStep}`,
                        `総ステップ数: ${window.tutorial.totalSteps}\nデータ読み込み: ${window.tutorial.tutorialSteps ? '成功' : '失敗'}`
                    );
                } else {
                    addResult('システム初期化', 'critical', 'tutorialオブジェクトの初期化に失敗');
                }
            }, 2000);
        });
    </script>
</body>
</html>